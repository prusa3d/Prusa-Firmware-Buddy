#pragma once

#include "Pin.hpp"
#include <inttypes.h>
#include "cmsis_os.h"
#include <cstring>
#include <array>
#include <bsod.h>
#include <limits>
#include "probe_analysis.hpp"
#include <atomic>

class Loadcell {
public:
    enum class TareMode {
        Continuous,
        Static,
    };

    Loadcell();

    buddy::ProbeAnalysis<300> analysis;
    std::atomic<bool> xy_endstop_enabled { false };

    void Tare(TareMode mode = TareMode::Static);

    void SetScale(float scale);
    float GetScale() const;

    void set_xy_endstop(const bool enabled);

    inline void SetThreshold(float threshold, TareMode tareMode) {
        switch (tareMode) {
        case TareMode::Static:
            thresholdStatic = threshold;
            break;
        case TareMode::Continuous:
            thresholdContinuous = threshold;
            break;
        }
    }
    inline float GetThreshold(TareMode tareMode) const {
        switch (tareMode) {
        case TareMode::Static:
            return thresholdStatic;
        case TareMode::Continuous:
            return thresholdContinuous;
        }
        return 0;
    }

    void SetHysteresis(float hysteresis);
    float GetHysteresis() const;

    void ProcessSample(int32_t loadcellRaw, uint32_t time_us);

    bool GetMinZEndstop() const;
    bool GetXYEndstop() const;

    void ConfigureSignalEvent(osThreadId threadId, int32_t signal);

    // return loadcell load in grams
    inline float GetLoad() const { return (scale * (loadcellRaw - offset)); }
    inline float GetHighPassLoad() const { return highPassFilter.GetOutput() * scale; }

    int32_t GetRawValue() const;

    bool IsSignalConfigured() const;

    /// @brief Request highest precision available from loadcell and wait for it.
    inline void EnableHighPrecision(bool wait = true) {
        highPrecision = true;
        if (wait)
            WaitForNextSample();
    }
    inline void DisableHighPrecision() { highPrecision = false; }
    inline bool IsHighPrecisionEnabled() const { return highPrecision; }

    void SetFailsOnLoadAbove(float failsOnLoadAbove);
    float GetFailsOnLoadAbove() const;

    void SetFailsOnLoadBelow(float failsOnLoadBelow);
    float GetFailsOnLoadBelow() const;

    /// @brief To be called during homing, will raise redsceen when samples stop comming during homing
    void HomingSafetyCheck() const;

    class IFailureEnforcer {
    protected:
        Loadcell &lcell;
        float oldErrThreshold;
        IFailureEnforcer(Loadcell &lcell, float oldErrThreshold);
        IFailureEnforcer(const IFailureEnforcer &) = delete;
        IFailureEnforcer(IFailureEnforcer &&) = default;
    };

    class FailureOnLoadAboveEnforcer : public IFailureEnforcer {
    public:
        FailureOnLoadAboveEnforcer(Loadcell &lcell, float grams, bool enable);
        FailureOnLoadAboveEnforcer(FailureOnLoadAboveEnforcer &&) = default;
        ~FailureOnLoadAboveEnforcer();
    };

    class FailureOnLoadBelowEnforcer : public IFailureEnforcer {
    public:
        FailureOnLoadBelowEnforcer(Loadcell &lcell, float grams);
        FailureOnLoadBelowEnforcer(FailureOnLoadBelowEnforcer &&) = default;
        ~FailureOnLoadBelowEnforcer();
    };

    class HighPrecisionEnabler {
    public:
        HighPrecisionEnabler(Loadcell &lcell, bool enable = true);
        HighPrecisionEnabler(HighPrecisionEnabler &&) = default;
        ~HighPrecisionEnabler();

    private:
        Loadcell &m_lcell;
    };

    FailureOnLoadAboveEnforcer CreateLoadAboveErrEnforcer(float grams = 3000, bool enable = true);

private:
    /// Implements Butterworth filter of 1st order for sample rate 76 Hz and corner freq. at 5 Hz
    ///
    /// Based on C implementation generated by mkfilter/mkshape/gencode   A.J. Fisher
    /// Command line: mkfilter -Bu -Hp -o 1 -a 4.8684210526e-01 0.0000000000e+00 -l
    class HighPassFilter {
    public:
        HighPassFilter() {
            Reset();
        }

        inline void Reset() {
            std::memset(&xv, 0, sizeof(xv));
            std::memset(&yv, 0, sizeof(xv));
        }

        inline float Filter(float input) {
            xv[0] = xv[1];
            xv[1] = xv[2];
            xv[2] = xv[3];
            xv[3] = xv[4];
            xv[4] = input / GAIN;
            yv[0] = yv[1];
            yv[1] = yv[2];
            yv[2] = yv[3];
            yv[3] = yv[4];
            yv[4] = (xv[0] + xv[4]) - 2 * xv[2]
                + (-0.7164075250f * yv[0]) + (3.0510427201f * yv[1])
                + (-4.9481816585f * yv[2]) + (3.6132919084f * yv[3]);
            return yv[4];
        }

        inline float GetOutput() const { return yv[1]; }

        /// How many samples it approximatelly takes for the filter to settle down.
        inline int GetSettlingTime() const { return 60; }

    private:
        static constexpr int NZEROS = 4;
        static constexpr int NPOLES = 4;
        static constexpr float GAIN = 5.724846511e+01f;

        float xv[NZEROS + 1];
        float yv[NPOLES + 1];
    };

    float scale;
    float thresholdStatic;
    float thresholdContinuous;
    float hysteresis;
    float failsOnLoadAbove;
    float failsOnLoadBelow;
    osThreadId threadId;
    int32_t signal;
    int32_t loadcellRaw;
    bool endstop;
    std::atomic<bool> xy_endstop;
    bool isSignalEventConfigured;
    bool highPrecision;

    // When tare is requested, this will store number of samples and countdown to zero
    std::atomic<uint32_t> tareCount;
    // This will contain summed samples from tare
    int32_t tareSum;

    TareMode tareMode;
    // used when tareMode == Static
    int32_t offset;
    // used when tareMode == Continuous
    HighPassFilter highPassFilter;

    /// Time when last valid sample arrived
    // atomic because its set in interrupt/puppytask, read in default task
    std::atomic<uint32_t> last_sample_time;

    int32_t WaitForNextSample();
};

extern Loadcell loadcell;
