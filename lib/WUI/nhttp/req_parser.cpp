#include "req_parser.h"
#include "handler.h"
#include "server.h"
#include <http/url_decode.h>
#include <timing.h>
#include <inttypes.h> // PRI* macros (not available in <cinttypes>)
#include "random.h"
#include "../wui_api.h"

#include <mbedtls/md5.h>

/*
 * The parsing automata. Generated by python scripts.
 */
#include <http_req_automaton.h>

#include <cassert>
#include <cstring>
#include <cmath>

extern "C" {

// Inject for tests, which are compiled on systems without it in the header.
size_t strlcpy(char *, const char *, size_t);
}

using namespace automata;
using http::Method;
using http::Status;
using http::url_decode;
using nhttp::parser::request::Names;
using std::get;
using std::get_if;
using std::holds_alternative;
using std::monostate;
using std::string_view;

namespace {

const Automaton http_request(nhttp::parser::request::paths, nhttp::parser::request::transitions, nhttp::parser::request::states);

}

namespace nhttp::handler {

uint32_t RequestParser::nonce_random = 0;

RequestParser::RequestParser(const Server &server)
    : Execution(&http_request)
    , server(&server)
    ,

    method(Method::UnknownMethod)
    , error_code(Status::UnknownStatus)
    , done(false)
    , version_major(0)
    , version_minor(0)
    , connection(Connection::Unknown)
    , accepts_json(false)
    , print_after_upload(false)
    , overwrite_file(false)
    // default authentication method when none comes
    , auth_status(DigestAuthParams()) {}

ExecutionControl RequestParser::event(Event event) {
    switch (event.leaving_state) {
    case Names::MethodGet:
        method = Method::Get;
        return ExecutionControl::Continue;
    case Names::MethodHead:
        method = Method::Head;
        return ExecutionControl::Continue;
    case Names::MethodPost:
        method = Method::Post;
        return ExecutionControl::Continue;
    case Names::MethodDelete:
        method = Method::Delete;
        return ExecutionControl::Continue;
    case Names::MethodPut:
        method = Method::Put;
        return ExecutionControl::Continue;
    case Names::MethodUnknown:
        method = Method::UnknownMethod;
        return ExecutionControl::Continue;
    }

    switch (event.entering_state) {
    case Names::PrintAfterUpload:
        print_after_upload = true;
        return ExecutionControl::Continue;
    case Names::Url:
        assert(boundary_size == 0);
        if (url_size < url.size()) {
            url[url_size++] = event.payload;
            return ExecutionControl::Continue;
        } else {
            error_code = Status::UriTooLong;
            return ExecutionControl::Continue;
        }
    case Names::Boundary:
        if (boundary_size + url_size < url.size()) {
            url[url_size + boundary_size++] = event.payload;
            return ExecutionControl::Continue;
        } else {
            error_code = Status::RequestHeaderFieldsTooLarge;
            return ExecutionControl::Continue;
        }
    case Names::Nonce: {
        if (!holds_alternative<DigestAuthParams>(auth_status)) {
            auth_status = DigestAuthParams {};
        }
        auto &digest_params = get<DigestAuthParams>(auth_status);
        uint8_t value;
        char c = event.payload;
        auto result = std::from_chars(&c, &c + 1, value, 16);
        if (result.ec != std::errc {}) {
            return ExecutionControl::Continue;
        }
        digest_params.recieved_nonce *= 16;
        digest_params.recieved_nonce += static_cast<uint64_t>(value);
        return ExecutionControl::Continue;
    }
    case Names::Response: {
        if (!holds_alternative<DigestAuthParams>(auth_status)) {
            auth_status = DigestAuthParams {};
        }
        auto &digest_params = get<DigestAuthParams>(auth_status);
        uint8_t value;
        char c = event.payload;
        auto result = std::from_chars(&c, &c + 1, value, 16);
        if (result.ec != std::errc {}) {
            return ExecutionControl::Continue;
        }
        digest_params.recieved_response[1] <<= 4;
        digest_params.recieved_response[1] |= (digest_params.recieved_response[0] & 0xf000000000000000) >> 60;
        digest_params.recieved_response[0] <<= 4;
        digest_params.recieved_response[0] |= value;
        return ExecutionControl::Continue;
    }
    case Names::XApiKey: {
        if (!holds_alternative<ApiKeyAuthParams>(auth_status)) {
            auth_status = ApiKeyAuthParams {};
        }
        auto &api_key_params = get<ApiKeyAuthParams>(auth_status);
        // No API key -> can't authenticate.
        if (!api_key) {
            api_key_params = false;
            return ExecutionControl::Continue;
        }
        // The first character, just starting.
        if (holds_alternative<monostate>(api_key_params)) {
            api_key_params = static_cast<uint8_t>(0);
        }
        if (uint8_t *idx = get_if<uint8_t>(&api_key_params); idx != nullptr) {
            const size_t key_len = strlen(api_key);
            if (*idx >= key_len || api_key[*idx] != event.payload) {
                api_key_params = false;
            } else if (++*idx == key_len) {
                api_key_params = true;
            }
        } else {
            api_key_params = false;
        }
        return ExecutionControl::Continue;
    }
    case Names::ContentLength:
        if (!content_length.has_value()) {
            content_length = 0;
        }
        *content_length = 10 * *content_length + (event.payload - '0');
        return ExecutionControl::Continue;
    case Names::Version:
        switch (event.payload) {
        case '.':
            version_major = version_minor;
            version_minor = 0;
            return ExecutionControl::Continue;
        case '0' ... '9':
            version_minor = 10 * version_minor + (event.payload - '0');
            return ExecutionControl::Continue;
        }
    case Names::IfNoneMatch:
        /*
         * We use numeric etags. If we get anything else, it's probably bogus
         * and won't match anyway... so let's just ignore it.
         */
        if (event.payload >= '0' && event.payload <= '9') {
            if_none_match = 10 * if_none_match + (event.payload - '0');
        }
        return ExecutionControl::Continue;
    case Names::ConnectionClose:
        connection = Connection::Close;
        break;
    case Names::ConnectionKeepAlive:
        connection = Connection::KeepAlive;
        break;
    case Names::AcceptJson:
        accepts_json = true;
        break;
    case Names::OverwriteFile:
        overwrite_file = true;
        return ExecutionControl::Continue;
    case Names::Body:
        done = true;
        // Yes, really don't stop. Eath the \n too!
        return ExecutionControl::Continue;
    }

    return ExecutionControl::Continue;
}

Step RequestParser::step(string_view input, bool terminated_by_client, uint8_t *, size_t) {
    if (done) {
        return Step { 0, 0, Continue() };
    }

    api_key = server->get_password();
    const auto [result, consumed] = consume(input);
    api_key = nullptr;

    if (!done && result == ExecutionControl::NoTransition) {
        // Malformed request
        error_code = Status::BadRequest;
        done = true;
    }

    if (!done && terminated_by_client) {
        // Incomplete request
        error_code = Status::BadRequest;
        done = true;
    }

    if (done) {

        /*
         * Note: we assume the array of selectors is terminated by one that
         * handles unhandled/unknown requests â€’ one that returns 404 or so.
         */
        for (const Selector *const *selector = server->selectors(); /* No condition on purpose*/; selector++) {
            if (auto state = (*selector)->accept(*this); state.has_value()) {
                return Step { consumed, 0, std::move(*state) };
            }
        }
    } else {
        return Step { consumed, 0, Continue() };
    }
}

bool RequestParser::can_keep_alive() const {
    return (connection == Connection::KeepAlive) || (version_major == 1 && version_minor >= 1 && connection != Connection::Close);
}

StatusPage::CloseHandling RequestParser::status_page_handling() const {
    return can_keep_alive() ? StatusPage::CloseHandling::KeepAlive : StatusPage::CloseHandling::Close;
}

bool RequestParser::uri_filename(char *buffer, size_t buffer_size) const {
    // Only up to ?, which are query params
    size_t len = url_size;
    if (const char *amp = static_cast<const char *>(memchr(url.begin(), '?', url_size)); amp) {
        len = amp - url.begin();
    }

    // FIXME: this is a bit stricter than necessary, if we have
    // some encoded values %?? we decode this 3 chars into one
    if (buffer_size < len) {
        return false;
    }

    string_view fname(url.begin(), len);
    if (!url_decode(fname, buffer, buffer_size)) {
        return false;
    }

    size_t url_len = strlen(buffer);
    string_view fname_decoded(buffer, url_len);
    // Make sure the user is not able to "escape" from directory.
    if (url_len >= 3 && (fname_decoded.substr(0, 3) == "../" || fname_decoded.substr(url_len - 3) == "/..")) {
        return false;
    }

    // It seems looking for a substring in a non-null-terminated string in C++
    // is kind of painful.
    for (size_t i = 0; i + 4 < url_len; i++) {
        if (fname_decoded.substr(i, 4) == "/../") {
            return false;
        }
    }

    return true;
}

bool RequestParser::nonce_valid(uint64_t nonce_to_check) const {
    uint32_t random = static_cast<uint32_t>(nonce_to_check >> 32);
    uint32_t time = nonce_to_check & 0xffffffff;
    auto age = ticks_s() - time;
    // sanity check
    if (age >= 0 && nonce_random != 0) {
        // really valid?
        if (random == nonce_random && age < 5)
            return true;
    }
    return false;
}
uint64_t RequestParser::new_nonce() const {
    return (static_cast<uint64_t>(nonce_random)) << 32 | (static_cast<uint64_t>(ticks_s()));
}

std::optional<std::variant<StatusPage, UnauthenticatedStatusPage>> RequestParser::authenticated_status(const ApiKeyAuthParams &params) const {
    if (holds_alternative<bool>(params) and get<bool>(params))
        return std::nullopt;
    else
        return UnauthenticatedStatusPage(status_page_handling(), accepts_json, ApiKeyAuth {});
}
std::optional<std::variant<StatusPage, UnauthenticatedStatusPage>> RequestParser::authenticated_status(const DigestAuthParams &params) const {
    if (nonce_random == 0) {
        if (!random32bit(&nonce_random)) {
            return StatusPage(Status::InternalServerError, status_page_handling(), accepts_json);
        }
    }
    if (nonce_valid(params.recieved_nonce)) {
        if (check_digest_auth(params.recieved_nonce)) {
            return std::nullopt;
        } else {
            return UnauthenticatedStatusPage(status_page_handling(), accepts_json, DigestAuth { new_nonce(), false });
        }
    } else {
        // We set stale=true for every nonce with valid digest for that nonce,
        // because it means the client knows the username and password and we want
        // him to retry with new nonce.
        bool stale = check_digest_auth(params.recieved_nonce);
        return UnauthenticatedStatusPage(status_page_handling(), accepts_json, DigestAuth { new_nonce(), stale });
    }
}

std::optional<std::variant<StatusPage, UnauthenticatedStatusPage>> RequestParser::authenticated_status() const {
    return std::visit([this](auto &params) { return authenticated_status(params); }, auth_status);
}

namespace {
    static const size_t MD5_SIZE = 16;
    static const size_t MD5_HEX_SIZE = 33;
    void md5_update(mbedtls_md5_context &ctx, string_view first) {
        mbedtls_md5_update(&ctx, (const uint8_t *)first.data(), first.size());
    }
    template <typename... Args>
    std::array<uint8_t, MD5_SIZE> md5_hash(Args... args) {
        std::array<uint8_t, MD5_SIZE> hash;
        mbedtls_md5_context ctx;
        mbedtls_md5_init(&ctx);
        mbedtls_md5_starts(&ctx);
        (md5_update(ctx, args), ...);
        mbedtls_md5_finish(&ctx, hash.data());
        mbedtls_md5_free(&ctx);

        return hash;
    }

    void hash_to_string(std::array<uint8_t, MD5_SIZE> hash, char *str, size_t str_size) {
        // + 1 for the '\0'
        assert(str_size >= 2 * hash.size() + 1);
        for (size_t i = 0; i < hash.size(); i++) {
            sprintf(str + i * 2, "%02x", hash[i]);
        }
    }
}

bool RequestParser::check_digest_auth(uint64_t nonce_to_use) const {
    if (auto digest_params = get_if<DigestAuthParams>(&auth_status)) {

        auto hash_a1 = md5_hash(PRUSA_LINK_USERNAME, ":", AUTH_REALM, ":", server->get_password());
        auto hash_a2 = md5_hash(to_str(method), ":", uri());

        char ha1[MD5_HEX_SIZE];
        hash_to_string(hash_a1, ha1, sizeof(ha1));

        char ha2[MD5_HEX_SIZE];
        hash_to_string(hash_a2, ha2, sizeof(ha2));

        char nonce_string[17];
        snprintf(nonce_string, sizeof(nonce_string), "%016" PRIx64, nonce_to_use);

        auto hash = md5_hash(ha1, ":", nonce_string, ":", ha2);

        for (size_t i = 0; i < MD5_SIZE; i++) {
            uint8_t to_compare {};
            if (i < 8)
                to_compare = (digest_params->recieved_response[1] << i * 8) >> 56;
            else
                to_compare = (digest_params->recieved_response[0] << (i - 8) * 8) >> 56;

            if (to_compare != hash[i])
                return false;
        }
        return true;
    }
    return false;
}

}
