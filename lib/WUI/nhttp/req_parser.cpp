#include "req_parser.h"
#include "handler.h"
#include "server.h"

/*
 * The parsing automata. Generated by python scripts.
 */
#include <http_req_automaton.h>

#include <cassert>
#include <cstring>

extern "C" {

// Inject for tests, which are compiled on systems without it in the header.
size_t strlcpy(char *, const char *, size_t);
}

using namespace automata;
using nhttp::parser::request::Names;
using std::get;
using std::get_if;
using std::holds_alternative;
using std::monostate;
using std::string_view;

namespace {

const Automaton http_request(nhttp::parser::request::paths, nhttp::parser::request::transitions, nhttp::parser::request::states);

}

namespace nhttp::handler {

RequestParser::RequestParser(const Server &server)
    : Execution(&http_request)
    , server(&server)
    ,

    method(Method::UnknownMethod)
    , error_code(Status::UnknownStatus)
    , done(false)
    , version_major(0)
    , version_minor(0)
    , connection(Connection::Unknown)
    , accepts_json(false) {}

ExecutionControl RequestParser::event(Event event) {
    switch (event.leaving_state) {
    case Names::MethodGet:
        method = Method::Get;
        return ExecutionControl::Continue;
    case Names::MethodHead:
        method = Method::Head;
        return ExecutionControl::Continue;
    case Names::MethodPost:
        method = Method::Post;
        return ExecutionControl::Continue;
    case Names::MethodDelete:
        method = Method::Delete;
        return ExecutionControl::Continue;
    case Names::MethodPut:
        method = Method::Put;
        return ExecutionControl::Continue;
    case Names::MethodUnknown:
        method = Method::UnknownMethod;
        return ExecutionControl::Continue;
    }

    switch (event.entering_state) {
    case Names::Url:
        assert(boundary_size == 0);
        if (url_size < url.size()) {
            url[url_size++] = event.payload;
            return ExecutionControl::Continue;
        } else {
            error_code = Status::UriTooLong;
            return ExecutionControl::Continue;
        }
    case Names::Boundary:
        if (boundary_size + url_size < url.size()) {
            url[url_size + boundary_size++] = event.payload;
            return ExecutionControl::Continue;
        } else {
            error_code = Status::RequestHeaderFieldsTooLarge;
            return ExecutionControl::Continue;
        }
    case Names::XApiKey:
        // No API key -> can't authenticate.
        if (!api_key) {
            auth_status = false;
            return ExecutionControl::Continue;
        }
        // The first character, just starting.
        if (holds_alternative<monostate>(auth_status)) {
            auth_status = static_cast<uint8_t>(0);
        }
        if (uint8_t *idx = get_if<uint8_t>(&auth_status); idx != nullptr) {
            const size_t key_len = strlen(api_key);
            if (*idx >= key_len || api_key[*idx] != event.payload) {
                auth_status = false;
            } else if (++*idx == key_len) {
                auth_status = true;
            }
        } else {
            auth_status = false;
        }
        return ExecutionControl::Continue;
    case Names::ContentLength:
        if (!content_length.has_value()) {
            content_length = 0;
        }
        *content_length = 10 * *content_length + (event.payload - '0');
        return ExecutionControl::Continue;
    case Names::Version:
        switch (event.payload) {
        case '.':
            version_major = version_minor;
            version_minor = 0;
            return ExecutionControl::Continue;
        case '0' ... '9':
            version_minor = 10 * version_minor + (event.payload - '0');
            return ExecutionControl::Continue;
        }
    case Names::IfNoneMatch:
        /*
         * We use numeric etags. If we get anything else, it's probably bogus
         * and won't match anyway... so let's just ignore it.
         */
        if (event.payload >= '0' && event.payload <= '9') {
            if_none_match = 10 * if_none_match + (event.payload - '0');
        }
        return ExecutionControl::Continue;
    case Names::ConnectionClose:
        connection = Connection::Close;
        break;
    case Names::ConnectionKeepAlive:
        connection = Connection::KeepAlive;
        break;
    case Names::AcceptJson:
        accepts_json = true;
        break;
    case Names::Body:
        done = true;
        // Yes, really don't stop. Eath the \n too!
        return ExecutionControl::Continue;
    }

    return ExecutionControl::Continue;
}

Step RequestParser::step(string_view input, bool terminated_by_client, uint8_t *, size_t) {
    if (done) {
        return Step { 0, 0, Continue() };
    }

    api_key = server->get_api_key();
    const auto [result, consumed] = consume(input);
    api_key = nullptr;

    if (!done && result == ExecutionControl::NoTransition) {
        // Malformed request
        error_code = Status::BadRequest;
        done = true;
    }

    if (!done && terminated_by_client) {
        // Incomplete request
        error_code = Status::BadRequest;
        done = true;
    }

    if (done) {
        /*
         * Note: we assume the array of selectors is terminated by one that
         * handles unhandled/unknown requests â€’ one that returns 404 or so.
         */
        for (const Selector *const *selector = server->selectors(); /* No condition on purpose*/; selector++) {
            if (auto state = (*selector)->accept(*this); state.has_value()) {
                return Step { consumed, 0, std::move(*state) };
            }
        }
    } else {
        return Step { consumed, 0, Continue() };
    }
}

bool RequestParser::can_keep_alive() const {
    return (connection == Connection::KeepAlive) || (version_major == 1 && version_minor >= 1 && connection != Connection::Close);
}

bool RequestParser::uri_filename(char *buffer, size_t buffer_size) const {
    // Only up to ?, which are query params
    size_t len = url_size;
    if (const char *amp = static_cast<const char *>(memchr(url.begin(), '?', url_size)); amp) {
        len = amp - url.begin();
    }

    // Make sure the user is not able to "escape" from directory.
    string_view fname(url.begin(), len);
    if (len >= 3 && (fname.substr(0, 3) == "../" || fname.substr(len - 3) == "/..")) {
        return false;
    }

    // It seems looking for a substring in a non-null-terminated string in C++
    // is kind of painful.
    for (size_t i = 0; i + 4 < len; i++) {
        if (fname.substr(i, 4) == "/../") {
            return false;
        }
    }

    // FIXME: Parsing and _validation_ of the URL:
    // * Demangling?
    if (buffer_size > len) {
        strlcpy(buffer, url.begin(), len + 1);
        return true;
    } else {
        return false;
    }
}

bool RequestParser::authenticated() const {
    return (holds_alternative<bool>(auth_status) && get<bool>(auth_status));
}

}
