#pragma once

/**
 * \file
 * \brief Tracking the state of gcode upload and parsing whatever needed.
 *
 * Each new upload creates an instance, feeds it with data and checks if
 * everything goes fine (the errors can happen anytime and it is up to the
 * caller to either check after each feeding or at the end).
 *
 * Internally, it calls the hooks from the http handlers. The finish is called
 * if it succeeds; otherwise it simply terminates without calling finish.
 *
 * The data fed to it may be split arbitrarily.
 */

#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>
#include <string_view>
#include <memory>
#include <tuple>

#include "../../src/gui/file_list_defs.h"
#include <http/types.h>

struct multipart_parser;

namespace nhttp::printer {

class UploadHooks {
public:
    using Result = std::tuple<http::Status, const char *>;
    virtual ~UploadHooks() = default;
    virtual Result data(std::string_view data) = 0;
    virtual Result finish(const char *final_filename, bool start_print) = 0;
    // Early check of a filename validity.
    //
    // Used once the file name is known, possibly before all the data is
    // uploaded.
    virtual Result check_filename(const char *final_filename) const = 0;
};

class UploadState {
private:
    /*
     * Internal "redirect" from static methods to real ones, generated by
     * macros and hidden in the cpp file.
     */
    class Adaptor;
    friend class Adaptor;

    static const constexpr size_t MAX_SUBTOKEN = 19;

    /*
     * A helper class that acts like a sliding window buffer. It is used to find
     * the right parts in stream of incoming characters.
     *
     * This is done by moving the whole buffer by a single character each time. It
     * is not exactly _optimal_ solution, but:
     * * This happens very seldom.
     * * The buffer is rather short.
     *
     * Therefore, we prefer simplicity over CPU performance. The alternative would
     * be something like a Aho-Corasick automaton built at compile time and
     * tracking only the ID of the state (which would make it faster and smaller in
     * RAM), but it is also a complex thing.
     */
    class Accumulator {
    private:
        std::string_view looking_for;
        uint8_t len : 7;
        bool sensitive : 1;
        std::array<char, MAX_SUBTOKEN> buffer;

    public:
        Accumulator();
        enum class Lookup {
            Found,
            NotYet,
            Overflow,
        };
        /*
         * Starts looking for specific substring.
         *
         * * Reset the buffer to be "empty".
         * * Start looking for the given string.
         * * Sensitive means if it should be case sensitive or not.
         */
        void start(const char *looking_for, bool sensitive);
        /*
         * Puts another character into the buffer.
         *
         * This potentially pushes the oldest one out in case the buffer is full.
         *
         * Returns if the substring has been found at this position or not. It may
         * return Overflow, which means the string already fed in here doesn't
         * match from the beginning. Depending on if you're looking for an
         * exact/full match or substring anywhere, you may take this as a "No
         * match" or "Keep looking".
         */
        Lookup feed(char c);
        // Is the buffer empty?
        bool empty() const {
            return len == 0;
        }
        /*
         * Returns the part of buffer before the looking-for string (as much of it as fits).
         *
         * If the looking-for string is considered a separator, the thing before it
         * is left in the buffer and can be accessed with this.
         *
         * The returned prefix can be shorter than whatever was fed into it before
         * the looking-for separator (in case oldest chars no longer fit). This is
         * OK in our use, as the buffer - separator is longer (due to other
         * reasons) than the constant strings we look for before the separator, so
         * in case something fell off the left side of the buffer, it would no
         * longer match anyway.
         */
        std::string_view prefix() const;
        /*
         * Access the internal buffer.
         *
         * This can be used to recycle the buffer for different purposes (to save
         * memory) while not being in used. The buffer or the functionality of
         * looking for something are mutually exclusive (use one or the other, not
         * both at the same time).
         */
        std::array<char, MAX_SUBTOKEN> &borrow_buf() {
            return buffer;
        }
    };

    class MultiparserDeleter {
    public:
        void operator()(multipart_parser *parser);
    };
    /*
     * This helps tracking if we start a new token or if this is a continuation
     * of the same one.
     */
    // Note: Use of 'enum class' generates a warning at the place of the
    // bitfield usage below, even though it is big enough.
    enum TokenType {
        NoToken,
        HeaderField,
        HeaderValue,
        DataToken,
        // Warning: Check the bitfield sizes if adding values.
    };

    /*
     * The states of the automaton.
     */
    enum State {
        NoState,
        CheckHeaderIsCDisp,
        IgnoredHeader,
        CDispHeader,
        ReadString,
        ReadPartName,
        Data,
        Done,
        // Warning: Check the bitfield sizes if adding values.
    };

    /*
     * Whenever we found a part of a known name, we record it by this.
     *
     * Anything unknown or before finding the name, it is Unknown and just
     * ignored.
     */
    enum Part {
        Unknown,
        Print,
        File,
        // Possibly others in the future
        // Warning: Check the bitfield sizes if adding values.
    };

    /**
     * The hooks.
     *
     * Not owned by us.
     */
    UploadHooks *hooks = nullptr;

    std::unique_ptr<multipart_parser, MultiparserDeleter> multiparter;

    /*
     * When reading a string separated by quotes, this points to the current
     * position and an end of a buffer to store it. This makes it possible to
     * point the reading of characters to different buffers depending on what
     * the string means.
     *
     * Relevant for the ReadString and ReadPartName states.
     *
     * When both are pointing to the same location, no more characters are read
     * and they are simply thrown away. The special-case of both pointing to
     * NULL is a /dev/null buffer for skipping until the end of a string that's
     * of no interest to us.
     */
    char *string_dst_pos = nullptr;
    const char *string_dst_end = nullptr;

    /*
     * A buffer for accumulating strings. See above.
     *
     * Warning/TODO: From time to time, its internal buffer is abused for other
     * purposes. This is a hack to save some memory and we are careful not to
     * use both at the same time (and to call a new .start after being molested
     * in this way). We hope the tests would catch anything if we mess up. If
     * you have a more elegant solution that isn't heavy-weight, proposals are
     * welcome.
     *
     * So far we tried to use std::variant and that turned a bit heavy. Using a
     * RAII object to „lock“ would mean having to store it somewhere, which is
     * also heavy-weight.
     */
    Accumulator accumulator;

    UploadHooks::Result error = std::make_tuple(http::Status::Ok, nullptr);

    TokenType type : 2;
    State state : 3;
    Part part : 2;
    bool have_valid_filename : 1;
    /*
     * The gcode_start hook has been called and we need to eventually call the finish hook too.
     *
     * This may get reset back to false in case the finish hook is called or
     * when there's an error from hook (the hooks should know they errored out
     * and clean up their state as needed).
     */
    bool init_done : 1;

    // The data ask us to start the print.
    bool start_print : 1;

    std::array<char, FILE_NAME_BUFFER_LEN> filename;

    int header_field(const std::string_view &payload);

    /*
     * The prefix of the accumulator contains the name of a field in the
     * content-disposition header. Decide what to do with it.
     */
    void handle_disp_field();
    int header_value(const std::string_view &payload);
    int headers_complete();
    int file_part(const std::string_view &payload);
    int print_part(const std::string_view &payload);
    int part_data(const std::string_view &payload);
    int part_data_end();
    int body_end();

    bool err_ok() const;

public:
    UploadState(const char *boundary);
    UploadState(const UploadState &other) = delete;
    UploadState(UploadState &&other) = default;
    UploadState &operator=(const UploadState &other) = delete;
    UploadState &operator=(UploadState &&other) = default;
    /**
     * \brief Sets the hooks to use.
     *
     * This can be called at arbitrary time to replace them. It can be used if
     * the initialization is lazy/delayed or if the hooks move between memory
     * locations between feeding.
     */
    void setup(UploadHooks *hooks);
    /**
     * \brief Inserts some more data.
     */
    void feed(const std::string_view &data);
    /// \brief Returns the last error state, if any.
    UploadHooks::Result get_error() const {
        return error;
    }
    /// \brief Returns the file name as specified in the form (if already known).
    const char *get_filename() const {
        return filename.begin();
    }
    /// \brief Returns true if the whole form was processed.
    bool done() const {
        return state == State::Done;
    }
};

} // namespace nhttp::printer
